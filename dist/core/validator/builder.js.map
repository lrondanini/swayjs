{"version":3,"file":"builder.js","sourceRoot":"","sources":["../../../src/core/validator/builder.ts"],"names":[],"mappings":"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","sourcesContent":["import { ParameterDeclaration, Project, PropertyDeclaration, PropertySignature, Type, TypeChecker } from \"ts-morph\";\nimport { Validator } from \"./validator\";\n\nexport enum ValidationRule {\n  IsType = 'IsType',\n  IsArray = 'IsArray',\n  IsObject = 'IsObject',\n  MaxLength = 'MaxLength',\n  MinLength = 'MinLength',\n  Contains = 'Contains',\n  Format = 'Format',\n  Max = 'Max',\n  Min = 'Min',\n  Custom = 'Custom',\n}\n\nexport enum BaseTypes {\n  String = 'string',\n  Number = 'number',\n  Boolean = 'boolean',\n  Enum = 'enum',\n  Any = 'any',\n  Unknown = 'unknown',\n  Object = 'object',\n}\n\nexport type ValidationRuleSetting = {\n  key: string; //to identify the rule and skip multiple evaluations\n  rule: ValidationRule;\n  type?: BaseTypes;\n  fullType?: string;\n  value?: number | string | boolean | string[] | number[] | boolean[];\n  rules?: PropRules[]; //for nested objects\n}\n\nexport type ValidationRules = {\n  and: ValidationRuleSetting[];\n  or: ValidationRuleSetting[][];\n}\n\nexport type PropRules = {\n  propName: string;\n  optional: boolean;\n  rules: ValidationRules;\n}\n\nconst utilForMatching = [ValidationRule.MaxLength, ValidationRule.MinLength, ValidationRule.Contains, ValidationRule.Format, ValidationRule.Min, ValidationRule.Max, ValidationRule.Custom];\n\nexport default class ValidatorFactory {\n  private currentParsedFile: string = '';\n  private currentParsedClass: string = '';\n\n  constructor() {\n  }\n\n  testCreateValidator(): Validator {\n    const validator = new Validator();\n    const project = new Project();\n    const sourceFiles = project.addSourceFilesAtPaths(`./routes/test.ts`);\n\n    sourceFiles.forEach((sourceFile) => {\n      this.currentParsedFile = sourceFile.getFilePath();\n\n      const classes = sourceFile.getClasses();\n      classes.forEach((classDef) => {\n        // console.log(classDef.getName());\n        classDef.getImplements().forEach((impl) => {\n          const requiresValidation = impl.getText().toLowerCase() === 'requiresvalidation';\n          if (requiresValidation) {\n            //class with functions to validate:\n            const methods = classDef.getMethods();\n            methods.forEach((method) => {\n              //in reality here we parse only routes methods.....Get, Post, .....\n              //here for testing we parse them all\n              \n              const validationRules: PropRules[] = [];\n              method.getParameters().forEach((param) => {\n                //PROD will need method name (to map the route methods), validator for the param\n                this.currentParsedClass = classDef.getName();\n                validationRules.push(this.parseParameter(param, project.getTypeChecker()));\n              });\n\n              // console.log(validationRules);\n              validator.addSchema(classDef.getName(), method.getName(), validationRules);\n            });\n\n            \n          }\n        });\n      });\n    });\n\n    return validator;\n\n  }\n\n  parseParameter(param: ParameterDeclaration, typeChecker: TypeChecker): PropRules {\n\n    let isOptional = this.isOptional(param.getName(), param.getText());\n\n    const paramType = typeChecker.getTypeAtLocation(param);\n\n    const rules = this.parseType(paramType, param.getText());\n\n    // console.log(\"RULES: \", JSON.stringify(rules, null, 2));\n\n    return {\n      propName: param.getName(),\n      optional: isOptional,\n      rules: rules,      \n    } as PropRules;\n\n  }\n\n  private getEnumValues(filPath: string, enumName: string): string[] {\n    const project = new Project();\n    let sourceFiles = project.addSourceFilesAtPaths(filPath + \".ts\");\n\n    if (sourceFiles.length == 0) {\n      sourceFiles = project.addSourceFilesAtPaths(filPath + \".tsx\");\n    }\n\n    if (sourceFiles.length == 0) {\n      throw new Error('File not found: ' + filPath + \".ts\");\n    }\n\n    const res: string[] = [];\n    sourceFiles.forEach((sourceFile) => {\n      sourceFile.getEnums().forEach((enumDef) => {\n        if (enumDef.getName() == enumName) {\n          enumDef.getMembers().forEach((member) => {\n            res.push(member.getName());\n          });\n        }\n      });\n    });\n    return res;\n  }\n\n  private parseProperty(prop: PropertyDeclaration | PropertySignature): PropRules {\n    const propName = prop.getName();\n    const type = prop.getType();\n\n    const propRules: PropRules = {\n      propName: propName,\n      optional: false,\n      rules: {\n        and: [],\n        or: [],\n      },\n    }\n\n\n    if (this.isOptional(propName, prop.getText())) {\n      propRules.optional = true;\n    }\n\n    propRules.rules = this.parseType(type, prop.getText());\n\n    return propRules;\n  }\n\n  private parseType(type: Type, propName: string): ValidationRules {\n\n    let rules: ValidationRules = {\n      and: [],\n      or: [],\n    }\n    if (type.isBoolean()) {\n      //keep this before union, as boolean is a union of true | false\n      rules.and.push({ rule: ValidationRule.IsType, type: BaseTypes.Boolean, key: 'is-type-boolean' });\n    } else if (type.isEnum()) {\n      //keep this before union, as enum is a union of all enum values (eg value1 | value2 | value3 | ....)      \n      const path = type.getText().split('.');\n      let values = [];\n      if (path.length > 1) {\n        const src = path[0].replace(\"import(\\\"\", \"\").replace(\"\\\")\", \"\");\n        values = this.getEnumValues(src, path[1]);\n      } else {\n        //its inside current file\n        values = this.getEnumValues(this.currentParsedFile.replace(\".ts\", \"\").replace(\".tsx\", \"\"), path[0]);\n      }\n      rules.and.push({ rule: ValidationRule.IsType, type: BaseTypes.Enum, value: values, key: 'is-type-enum' + JSON.stringify(values) });\n    } else if (type.isIntersection()) {\n      // console.log(type.getIntersectionTypes());\n      type.getIntersectionTypes().forEach((intType) => {\n        rules.and = [...rules.and, ...this.parseType(intType, propName).and];\n      });\n    } else if (type.isUnion()) {\n      type.getUnionTypes().forEach((intType) => {\n        rules.or.push(this.parseType(intType, propName).and);\n      });\n    } else if (type.isArray()) {\n      rules.and = [...rules.and, ...this.parseArray(type, propName)];\n    } else if (type.isLiteral()) {\n      ///TODO---------------------------------------\n      ///TODO---------------------------------------\n      ///TODO---------------------------------------\n      console.log(' isLiteral');\n    } else if (type.isNumber()) {\n      rules.and.push({ rule: ValidationRule.IsType, type: BaseTypes.Number, key: 'is-type-number' }); \n    } else if (type.isObject()) {\n      if (type.getText().toLowerCase().includes('ValidationRule'.toLowerCase())) {\n        const t = type.getText().split('.');\n        const rule = t[t.length - 1];\n        rules.and.push(this.parseValidationRule(rule));\n      } else {\n        //some object (ignore validation rules of subobject for this release)\n        const path = type.getText().split('.');\n        const src = path[0].replace(\"import(\\\"\", \"\").replace(\"\\\")\", \"\");\n\n        if(!path[1]) {\n          throw new Error('Object type not found or exported: ' + type.getText());\n        }\n\n        const objProRules = this.parseObject(src, path[1]);\n        rules.and.push({ rule: ValidationRule.IsObject, type: BaseTypes.Any, key: 'is-type-object', rules:  objProRules});\n      }\n    } else if (type.isString()) {\n      rules.and.push({ rule: ValidationRule.IsType, type: BaseTypes.String, key: 'is-type-string' });\n    } else if (type.isAny) {\n      //keep this as last, any is a superset of all types      \n      rules.and.push({ rule: ValidationRule.IsType, type: BaseTypes.Any, key: 'is-type-any' });//includes any, undefined and null  \n    }\n\n\n    return rules;\n  }\n\n  private parseObject(filPath: string, objectName: string): PropRules[] {\n    const validationRules: PropRules[] = [];\n    const project = new Project();\n\n    let sourceFiles = project.addSourceFilesAtPaths(filPath + \".ts\");\n\n    if (sourceFiles.length == 0) {\n      sourceFiles = project.addSourceFilesAtPaths(filPath + \".tsx\");\n    }\n\n    if (sourceFiles.length == 0) {\n      throw new Error('File not found: ' + filPath + \".ts\");\n    }\n\n    sourceFiles.forEach((sourceFile) => {\n      this.currentParsedFile = sourceFile.getFilePath();\n\n      let found = false;\n      const classes = sourceFile.getClasses();\n      classes.forEach((classDef) => {\n        if(classDef.getName() == objectName) {\n          found = true;\n          classDef.getProperties().forEach((prop) => {\n            this.currentParsedClass = classDef.getName();\n            validationRules.push(this.parseProperty(prop));\n          });\n        }\n      });\n\n      if(!found) {\n        const interfaces = sourceFile.getInterfaces();\n        interfaces.forEach((interfaceDef) => {\n          if(interfaceDef.getName() == objectName) {\n            interfaceDef.getProperties().forEach((prop) => {\n              this.currentParsedClass = interfaceDef.getName();\n              validationRules.push(this.parseProperty(prop));\n            });\n          }\n        });\n      }\n    });\n\n    return validationRules;\n  }\n\n  private parseArray(type: Type, propName: string) {\n    let rules: ValidationRuleSetting[] = [];\n    const t = this.parseType(type.getArrayElementType(), propName).and;\n    if (t.length == 1) {\n      if (t[0].type == BaseTypes.Enum) {\n        const path = type.getText().split('.');\n        const src = path[0].replace(\"import(\\\"\", \"\").replace(\"\\\")\", \"\");\n        const values = this.getEnumValues(src, path[1].replace(\"[\", \"\").replace(\"]\", \"\"));\n        rules.push({ rule: ValidationRule.IsArray, type: t[0].type, value: values, key: 'is-array-of-' + t[0].type + JSON.stringify(values) });\n      } else if((t[0].rule == ValidationRule.IsObject) && t[0].rules && t[0].rules.length > 0) {\n        rules.push({ rule: ValidationRule.IsArray, type: BaseTypes.Object, fullType: type.getText(), key: 'is-array-of-object', rules: t[0].rules  });\n      } else {\n        rules.push({ rule: ValidationRule.IsArray, type: t[0].type, key: 'is-array-of-' + t[0].type});\n      }\n    } else {\n      //what is not supported????\n      throw new Error('Validation not supported for ' + this.currentParsedClass + '.' + propName + ' (' + this.currentParsedFile + ')');\n    }\n    // console.log(rules);\n    return rules;\n  }\n\n  private getRuleName(rule: string): ValidationRule {\n    for (const item of utilForMatching) {\n      if (rule.includes(item)) {\n        return item;\n      }\n    }\n  }\n\n  private parseValidationRule(rule: string): ValidationRuleSetting {\n    const ruleName: ValidationRule = this.getRuleName(rule);\n    let regex = new RegExp(String.raw`^${ruleName}\\s*<\\s*(.*)\\s*>`);\n\n    switch (ruleName) {\n      case ValidationRule.MinLength:\n      case ValidationRule.Contains:\n      case ValidationRule.Min:\n      case ValidationRule.Max:\n      case ValidationRule.MaxLength: {\n        const matches = regex.exec(rule);\n        let value = parseInt(matches[1]);\n        if (ruleName == ValidationRule.Contains) {\n          if (Number.isNaN(value)) {\n            value = JSON.parse(matches[1]);\n          }\n        }\n        return {\n          rule: ruleName,\n          value: value,\n          key: ruleName + value,\n        };\n      }\n\n      case ValidationRule.Custom:\n      case ValidationRule.Format: {\n        const matches = regex.exec(rule);\n        let value = JSON.parse(matches[1]);\n        return {\n          rule: ruleName,\n          value: value,\n          key: ruleName + value,\n        };\n      }\n\n    }\n  }\n\n  private isOptional(name: string, input: string) {\n    // /^base(\\s*)\\?(\\s*):(.*)/\n    let regex = new RegExp(String.raw`^${name.trim()}(\\s*)\\?(\\s*):(.*)`);\n    return regex.test(input);\n  }\n\n}"]}